# 체스 게임

## 기능 목록

### Board
- [x] 8 x 8 크기를 가진다.
  - [x] 8개의 파일(File)과 8개의 랭크(Rank)를 가진다.
    - 파일 : 왼쪽부터 a ~ h
    - 랭크 : 아래부터 위로 1 ~ 8
  - [x] 각 칸에 기물(Piece)이 올라갈 수 있다.

### Piece
- [x] 6종류가 있다.
  - 킹, 퀸, 비숍, 나이트, 룩, 퀸
- [x] 움직일 수 있다.
  - [x] 종류 별로 다르게 움직일 수 있다.
    - [x] 킹 : 전후좌우, 대각선 한 칸씩
    - [x] 퀸 : 전후좌우, 대각선 칸 수 제한 X
    - [x] 나이트
      - [x] 두 칸 전진한 상태에서 좌우로 한 칸 이동
      - [x] 도착지에만 아군이 없으면 이동 가능
    - [x] 룩 : 전후,현 좌우 칸 수 제한 X
    - [x] 비숍 : 대각선 칸 수 제한 X
    - [x] 폰
      - [x] 한 칸씩 전진
      - [x] 초기상태에만 한 칸 혹은 두 칸 전진
      - [x] 전방 대각에 적이 존재하면 해당 방향으로 한 칸 이동 가능

### OutputView
- [x] 게임 시작 메시지를 출력할 수 있다.
- [x] 게임 시작/종료 여부 입력 메시지를 출력할 수 있다.
- [x] 보드판을 출력할 수 있다.

### InputView
- [x] 게임 시작/종료 여부를 입력할 수 있다.
  - [x] 'start' 또는 'end'가 아니면 예외처리한다.

## 1단계 리팩토링
### 1차 리뷰
- [x] getValuePoint 메서드명 개선
- [x] initBoardSpaces for문 8의 의미는?
- [x] 각 말을 표시하는 방법은 어느 영역의 관심사일까?
- [x] 컨트롤러의 repeat 메서드명 개선
- [x] Knight getPaths가 사용하지 않음을 나타내자.
  - 현재 Piece들은 이동을 하면서 getPaths() 메서드를 통해 이동 경로를 반환한다.
  - 하지만, Knight는 이동 경로에 존재하는 말들을 뛰어 넘을 수 있기 때문에 getPaths() 메서드가 빈 리스트를 반환하며 도착지점에 말이 있는지만 확인하도록 설계했다.
  - 즉, 상속을 통한 다형성을 이용하기 위해 Knight는 필요로 하지 않는 getPaths를 구현한 것이다.
  - 이는 ISP를 위반하는 것이고, 사용하지 말아야 될까?
  - 사용한다면, 수정한 것처럼 주석을 통해 나타내도 괜찮을까?
- [x] Pawn 매직 넘버 개선
- [x] Piece.move()는 부모 클래스가 자식 클래스에 의존하는, 즉, DIP 위반 아닐까?
- [x] indexOf 메서드에 List에 존재하지 않는 값을 전달한다면?
  - 현재 로직에선 Board.movePiece()에서 null이 아닌 sourcePiece를 전달하도록 설계돼있다고 생각한다.
  - 이렇게 당장의 설계상으로는 null이 되지 않는 경우에도 NPE를 방지해야 될지? NPE 방지의 범위와 기준이 잘 안 잡히는 것 같다.
- [x] ChessController와 InputView가 같은 문자열이 있는데, 이는 같은 의미를 가지는 걸까?
- [x] Calculator 주석 제거
- [x] Position getSlope() 내에서 0으로 나눠지는 경우 예외 처리
- [x] 이동 순서 제한
- [x] 폰 대각 이동 조건
- [x] 말 제거 기능

### 궁금한 점
- 각 기물의 이름("k", "K", "q", ...)은 도메인 로직에 쓰이지 않는다. 오직 사용자에게 보여주기 위함이다. 즉, 뷰를 위해 존재하는데 이를 기물 객체가 상태로 관리할 필요가 있을까?
- 이동 경로를 검사할 필요 없는 기물(Non-Sliding Piece)은 getPaths 메서드에서 emptyList를 반환하고 있다.
  - getPaths 메서드는 다른 개발자로 하여금 경로를 반환해줄 것이라고 예상하게 된다.
    - ex) 나이트는 위,위,오른쪽 과 같은 경로를 반환할 것이다
  - 하지만 지금처럼 getPaths() 메서드가 경우에 따라 emptyList를 반환한다면, getPaths를 사용하는 개발자가 예상하지 못했던 동작을 할 수도 있을 것이다.
  - 이를 해결하기 위한 방법을 생각해 봤다.
    - Piece 클래스를 상속하는 SlidingPiece, NonSlidingPiece 추상 클래스로 나눈다.
    - SlidingPiece 클래스는 경로 반환 메서드를 추상 메서드로 갖는다.
    - NonSlidingPiece 클래스는 경로 반환이 필요 없기 때문에 해당 메서드를 가지지 않는다.
    - Board에서는 SlidingPiece가 이동할 때만 경로 검사를 한다.
  - 이런 상속 구조를 가져갔을 때, 다음 문제가 발생한다.
    - Board에서는 Piece 클래스를 통해 기물 객체와 소통하게 될 것이다. 
    - SlidingPiece일 때만 경로 검사를 하려면, 소통하고 있는 Piece가 SlidingPiece인지 검사해야 된다.
    - 검사한 뒤에는 원래 다루던 서브클래스 객체로 SlidingPiece를 생성해줘야 된다.
  - 이를 해결하기 위해서는 instanceOf를 통해 SlidingPiece인지 검사하고, 맞다면 SldiingPiece로 다시 생성해주는 코드가 필요하다.
  - 그럴 바엔 NonSlidingPiece도 getPaths를 가지되, emptyList를 반환하도록 하는 것이 타협점일 것 같다 ..
    - 이런 방법도 getPaths가 emptyList를 반환함으로써 다른 개발자가 예상치 못한 동작을 할 수 있다는 점은 해결하지 못 한다.
    - 하지만 **NonSlidingPiece로 묶어주면서** emptyList를 반환한다는 점에서 조금 더 해석의 여지가 생기지 않나 싶은 마음이다

## 3단계
- King이 잡혔을 때 게임을 종료해야 한다.
- 게임이 종료되면 현재 남아 있는 말에 대한 점수를 구할 수 있어야 한다.
- 게임이 종료된 후, "status" 명령을 입력하면 각 진영의 점수를 출력하고 어느 진영이 이겼는지 결과를 볼 수 있어야 한다.

### status
- [x] status 출력 메시지
- [x] status 입력
  - [x] [예외처리] status 문자열 검사
- [x] status 출력

### 점수
- [x] 각 말들은 점수를 가진다.
- [x] 남아 있는 말들의 점수를 합한다.
  - [x] 남아 있는 말들을 진영으로 구분한다.

### 게임 종료
- [x] King이 잡혔는지 검사한다.

### 궁금한 점
- 각 기물들은 점수를 가지고 있다. 현재로써는 이 점수가 변경되지 않는데, 이를 상태로 가지고 있을 필요가 있는가? 상태로 갖지 않고 `getScore` 메서드에서 바로 값을 반환한다면 어떨까? 
