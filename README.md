# java-chess

체스 미션 저장소

## 우아한테크코스 코드리뷰

- [온라인 코드 리뷰 과정](https://github.com/woowacourse/woowacourse-docs/blob/master/maincourse/README.md)

---

## 용어 정리

- rank: 체스판에서의 가로줄(row)을 의미
- file: 체스판에서의 세로줄(column)을 의미
- square: 체스판의 한 칸을 의미
- turn: 해당 시점에서 게임을 진행중인 팀을 의미

---

## 프로그램 실행

- docker-compose.yml이 있는 경로에서 docker 명령어로 서버 실행(ex. docker-compose -p chess up -d)
    - init.sql을 통해 실제 게임이 진행되는 chess DB와 테스트에 사용되는 chess-test DB가 생성됨
- 애플리케이션 실행시 현재 진행중인 게임 목록이 표시됨
    - 진행중인 게임이 없다면 게임 목록은 비어있음
- 원하는 게임을 선택하거나 0을 입력해 새 게임 실행
- start, move, end, status 명령어를 사용해 게임 진행

---

## 기능 요구 사항

### 입력

-[x] 사용자로부터 command 입력을 받는다
    - [x] start를 입력하면 게임을 시작한다
    - [x] end를 입력하면 게임이 종료된다
    - [x] move를 입력하면 말이 이동한다
        - [x] 입력은 move source위치 target위치 의 형태로 입력한다
    - [x] status를 입력하면 현재 상태의 결과를 볼 수 있다
- [x] 올바르지 않은 명령을 입력하면 다시 입력받는다.

### 게임 진행

- [x] 체스판을 초기화한다
    - [x] 말의 위치 값은 가로 위치는 왼쪽부터 a ~ h이다
    - [x] 말의 위치 값은 세로는 아래부터 위로 1 ~ 8이다
    - [x] 체스판에서 각 진영은 검은색(대문자)과 흰색(소문자) 편으로 구분한다

### 게임 규칙

- [x] White팀, Black팀이 번갈아가면서 게임을 진행한다
    - [x] 게임을 시작하면 White팀이 먼저 턴을 시작한다
- [x] 나이트를 제외한 다른 말들은 경로 상에 다른 말이 있다면 뛰어넘을 수 없다
- [x] King
    - [x] 상, 하, 좌, 우, 대각선으로 한 칸만 움직일 수 있다
- [x] Queen
    - [x] 상, 하, 좌, 우, 대각선으로 움직일 수 있다
- [x] Rook
    - [x] 상, 하, 좌, 우로 움직일 수 있다
- [x] Knight
    - [x] 상, 하 1칸 + 좌, 우 2칸 / 상, 하 2칸 + 좌, 우 1칸으로 움직일 수 있다
    - [x] 이동 경로에 다른 말이 있어도 뛰어넘어 움직일 수 있다
- [x] Bishop
    - [x] 대각선으로 움직일 수 있다
- [x] Pawn
    - [x] 첫 이동은 상대 방향으로 1칸, 혹은 2칸 움직일 수 있다
    - [x] 첫 이동이 아닌 경우 상대 방향으로 1칸만 움직일 수 있다
    - [x] 대각선에 상대방 말이 있는 경우 말을 잡고, 그 위치로 이동할 수 있다

### 게임 승패 판단

- [x] King이 잡히면 게임에서 진다
    - [x] 두 팀중 한팀이라도 King이 잡히면 게임이 종료된다
- [x] 현재까지 남아있는 말에 대한 점수를 계산한다
    - [x] Queen(9점), Rook(5점), Bishop(3점), Knight(2.5점), King(0점)이다
    - [x] Pawn 기본점수는 1점이며 세로줄에 같은 색의 폰이 있는 경우에는 0.5점이다
    - [x] 점수가 큰 팀이 승리한다

### 출력

- [x] 체스판을 출력한다
- [x] King이 잡히면 각 팀의 승패 결과를 출력한다
- [x] 각 팀의 점수와 승패 결과를 출력한다

### 4단계 기능 요구 사항 - DB 적용

- [x] 애플리케이션을 재시작하더라도 이전에 하던 체스 게임을 다시 시작할 수 있어야 한다
    - [x] 데이터베이스에 현재 게임 진행 상황을 저장한다
    - [x] 애플리케이션을 재시작하면 저장된 데이터를 불러온다
- [x] 사용자별로 체스 게임 기록을 관리한다
    - [x] 체스 게임방을 만든다
    - [x] 체스 게임방에 입장할 수 있다

---

## 3, 4단계 고민한 포인트

### 테스트용 데이터베이스는 어떻게 해야할까

이번 과제를 진행하면서 가장 많이 고민했던 부분입니다.  <br>
테스트를 할 때 게임이 진행중인 데이터를 건드리지는 않아야하고, 테스트 전/후 데이터베이스 상태를 조절할 수 있어야한다고 생각했습니다.<br>
그래서 생각했던 방법이 총 세 가지였어요.<br>
① 애플리케이션에 사용되는 데이터베이스, 테이블을 사용해서 테스트하고 테스트가 끝나면 다시 원래 상태로 복구하기<br>
⇒ 기존 데이터베이스를 테스트에 사용하는것이 적절하지 않다고 생각해서 적용하지 않았습니다.<br><br>
아래 ②, ③번 방식으로 구현하면서 BeforeEach를 사용해서 테스트가 시작될때마다 테스트용 데이터를 초기화하도록했습니다.(DaoTest에서 초기화)<br>
② 테스트 / 프로덕션용 테이블 분리<br>
⇒ chessboard, chessboard_for_test 테이블을 별도로 만든 뒤 테스트 실행시 chessboard_for_test 테이블을, 애플리케이션 실행시에는 chessboard를 사용하도록
했습니다.<br>
이렇게 구현하니 실제데이터를 건드리지않고 테스트/애플리케이션 실행 모두 가능했습니다. 그러나 테스트 중인지 아닌지 검증하는 코드가 도메인에 들어가게되어 이 방법 또한 적절하지 않은 것 같았습니다.<br>
③ 테스트용 DB와 실제 DB 분리<br>
⇒ 테스트에 사용될 DB와 실제 게임에 사용되는 DB를 분리하였습니다.<br>
프로그램 실행시에는 chess 데이터베이스를, 테스트시에는 chess-test 데이터베이스를 사용했습니다. 상황에 따라 다른 데이터베이스를 적용해야하므로 ConnectionGenerator를 통해 각각의 값을
적용시켰습니다. (혹은 DB 이름을 전달받아서 Connection에 사용하게 만들수도 있을 것 같습니다.)<br>
이 또한 작동은 하지만 애플리케이션, 테스트를 위해 사용되는 데이터베이스를 코드상에서 지정해주어야해서 적절할지 고민됩니다.<br>

### DAO는 어디에서 사용해야하는가

데이터베이스는 어디에서 접근해야하는가에 대한 궁금증이 생겼습니다. 코드를 구현하며 데이터베이스에 접근하기 위해 Dao를 사용하였습니다.<br>
MVC 패턴에서 데이터베이스와 상호작용하는 부분이 Model이라고 생각했습니다.(구조: View ⇄ Controller ⇄ Model ⇄ Database)<br>
현재 체스게임을 주관하고 모든 정보를 가지고있는 ChessGame 클래스에서 Dao를 사용하고있습니다.<br>
뿐만 아니라 초기 게임목록 출력에도 데이터가 필요해서 Controller에서도 Dao를 한번 사용하고있습니다.<br>
이렇게 구현하니 필드 개수도 주어진 제약조건을 만족하지 못하고, 역할 분리도 이루어지지 못한 것 같습니다.<br>
찾다보니 Service의 개념도 언급되는데 dao를 필드로 갖는 service를 별도로 두고 controller에서 사용해야하는건지, ChessGame 자체가 service의 역할을 하는건지 궁금합니다.

---

## 1, 2단계 고민한 포인트

### Position 캐싱 적용

체스판에는 64개의 고정된 위치가 있습니다. 체스 말을 이동할 때 명령어에 해당하는 Position을 찾아야 합니다.<br>
이때마다 Position을 새로 생성하는것은 효율적이지 못하다고 생각했습니다. 그래서 캐싱을 적용하고 file, rank에 해당되는 Position을 리턴하도록 했습니다.

### Piece(체스 말), GameState(현재 게임 진행 상태) 구현 방식

인터페이스에 체스 말에 따라 달라질 동작들을 지정해두고 이를 구현하는 각 클래스에서 말의 종류에 따른 동작을 정의하도록 하였습니다.<br>
이 때 Piece 구현 클래스의 경우 어느 팀의 말인지 알기 위해 Color를 필드로 갖습니다.
Piece를 구현한 모든 클래스에 Color 필드가 있고 필드를 사용하는 공통된 메서드가 중복으로 존재합니다.<br>
만약 인터페이스 구현 방식이 아니라 상속을 사용하면 중복 필드와 중복 메서드를 줄일 수 있습니다.
이렇게 중복 코드와 중복 메서드가 있는 경우 혹시 어떤 방식을 사용하시는지 궁금합니다.<br>
-> 제가 생각한 결론: 상속의 경우 기능 확장, 수정에 제한이 생길 수 있습니다.
만약 각 Piece구현 클래스들에 새로운 기능목록이 추가되어야한다면 상속을 통해 구현한 경우 다중 상속을 할 수 없습니다. 또한 상위 클래스의 변경에 영향을 받습니다. <br>
인터페이스로 구현한 경우 여러 인터페이스를 구현하는것이 가능합니다.
중복 코드가 발생한다는 점은 있지만 확장, 수정 가능성을 고려하면 인터페이스 활용이 더 유연하다고 생각해서 인터페이스를 적용했습니다.

### 테스트 코드 필드 초기화

페어와 테스트코드를 작성하다가 필드 초기화 관련 궁금증이 생겼습니다.
Piece(Pawn, Knight, King 등)의 테스트는 해당 말이 주어진 위치에서 다른 위치로 이동할 수 있는지 확인하고 있습니다.<br>
이 때 각 테스트에서 Piece는 동일하게 사용되므로 테스트코드 밖에서 초기화 해주었습니다.
이 때 어짜피 변경되지 않는 값이라면 ```@BeforeEach```를 사용하지 않고 처음 한번만 ```Bishop bishop = new Bishop(Color.WHITE);``` 로
해주어도 되지 않는가 하는 이야기가 나왔습니다.<br>
혹시 이렇게 변경되지 않는 값이라면 굳이 @BeforeEach를 사용하지 않고 한번만 초기화해주어도 될까요?<br>
-> 제가 생각한 결론: 지금 현재는 생성된 piece에 영향을 주는 테스트 케이스가 없지만 향후 다른 케이스가 추가될 수도 있고,
테스트를 할 때에는 초기 상태가 항상 정확하게 관리되어야 할 것 같습니다.<br>
그래서 각 테스트케이스가 수행되기 전에 @BeforeEach로 초기화 되도록 하였습니다.

### 리플렉션을 활용한 테스트

이번 미션의 요구사항 중 getter를 사용하지 않는다는 조건이 있었습니다. 그래서 테스트를 위한 getter도 최대한 사용하지 않고 구현하려고 노력했습니다.<br>
하지만 테스트를 하며 필드에 접근해야하는 경우가 있었고 리플렉션을 통해 접근할 수 있다는 것을 알게 되었습니다.<br>
이 방법을 통해 getter 없이 테스트는 할 수 있었으나 이 방식이 나은지, 혹은 정말 필요하다면 getter를 열어두는것이 나은지 고민되었습니다.
혹시 현업에서도 이 방식을 사용하시는지 궁금합니다!<br>
-> 리플렉션에 대해서는 아직 이해가 부족해서 추가로 학습해야할 것 같습니다.
